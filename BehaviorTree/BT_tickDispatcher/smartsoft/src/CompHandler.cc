//--------------------------------------------------------------------------
// Code generated by the SmartSoft MDSD Toolchain
// The SmartSoft Toolchain has been developed by:
//  
// Service Robotics Research Center
// University of Applied Sciences Ulm
// Prittwitzstr. 10
// 89075 Ulm (Germany)
//
// Information about the SmartSoft MDSD Toolchain is available at:
// www.servicerobotik-ulm.de
//
// This file is generated once. Modify this file to your needs. 
// If you want the toolchain to re-generate this file, please 
// delete it before running the code generator.
//--------------------------------------------------------------------------

#include <iostream>

#include <vector>

#include "CompHandler.hh"
#include "BT_tickDispatcher.hh"
#include "BT_tickDispatcherCore.hh"

#include "tickers/ITickable.h"
#include "tickers/yarpTicker.h"
#include "tickers/RelayTicker.h"
#include "tickers/SmartTicker.h"

#include <yarp/os/LogStream.h>

using namespace std;


void CompHandler::onStartup() 
{
	std::cout << "startup - put your startupCode in CompHandler::onStartup()!!!\n";

	Smart::StatusCode status;

	COMP->stateMaster = new SmartACE::StateMaster(COMP->component);

	/* Load config file */
	std::string file(COMP->getGlobalState().getSettings().getConfigFile());

    std::ifstream myFile;

    vector<vector<string> > inputData;

    myFile.open(file.c_str() , std::ios::in);
    if(!myFile.is_open())
    {
		std::string errorStr = "\nerror opening file " + file;
		throw std::invalid_argument(errorStr);
    }
    else
    {
		/* Read it */
		string line;
		std::cout << "\n reading file " << file << std::endl;

		while(!myFile.eof())
		{
			getline(myFile, line);

//			std::cout << "Got a new line:  " << line << std::endl;

			istringstream ticker(line);
			vector<string> tokens {istream_iterator<string>{ticker}, istream_iterator<string>{}};

//			std::cout << "tokens size:  " << tokens.size() << std::endl;

			if(tokens.size() == 0)		// skip blank lines
				continue;

	    	if(tokens.size() < 4)
	    	{
	    		std::cout << "Error: line " << line << " malformed. Some parameters are missing";
	    		continue;
	    	}

/*
			for(int i=0;  i< tokens.size(); i++)
				std::cout << i << " " << tokens[i] << std::endl;
*/
			inputData.push_back(tokens);
		}
		myFile.close();
		std::cout << "Config file loaded\n";
    }


    struct tmp
	{
		string  skillName;
		decltype(COMP->bT_Navig_tick) port;
	};

    vector<tmp> tmpVect { 	{"navigation",   COMP->bT_Navig_tick},
    						{"manipulation", COMP->bT_manip_tick},
							{"vision", 		 COMP->bT_vision_tick}
    					};

    // Create default relay tickers associated with SmartSoft port in a static way.
    std::cout << "Creating a new <RelayTicker> ... ";

	for(tmp elem : tmpVect)
	{
		RelayTicker *t = new RelayTicker(elem.port);		// create new SmartSoft ticker
		t->configure(elem.skillName);
		// Info entry.tickerInstance *(t);
		COMP->tickables_map[elem.skillName] = {	elem.skillName, // <-- Info object initialization
												"RelayTicker",
												elem.skillName,
												"tick",
												"",
												t};				// add entry in the map
		COMP->smartTickers_list.emplace_back(t);				// keep a list of ticker to easily destroy them at the closure
	}


    /* Instantiate devices */
    for (auto tokens : inputData)
    {
    	Info entry;

		for(int i=0; i<tokens.size(); i++)
			std::cout << tokens[i] << "  |  ";

		entry.skill2Tick = tokens[0];
		entry.tickerType = tokens[1];
		entry.tickerId   = tokens[2];
		entry.command    = tokens[3];


		// recpnstruct params as a unique string
		if(tokens.size() >= 5)
			entry.params     = tokens[4];

		for(int i=5; i<tokens.size(); i++)
			entry.params     += " " + tokens[i];

		bool found = false;
		for (auto &elem : COMP->tickables_map)
		{
			if( (elem.second.tickerType == entry.tickerType) && (elem.second.tickerId == entry.tickerId) )
			{
				// Ticker already exists.
				std::cout << "Using an already existing ticker ... ";
				found = true;
				entry.tickerInstance = elem.second.tickerInstance;		// re-cycle already existing ticker
				COMP->tickables_map[entry.skill2Tick] = entry;			// add entry in the map
				break;
			}
		}
		std::cout << std::endl;

		if(!found)		// create new instance
		{
			bool success = true;
			std::cout << "Creating a new <" << entry.tickerType << "> ... ";

			if(entry.tickerType == "yarp")
			{
				YarpTicker *t = new YarpTicker();							// create new yarp ticker
				success = t->configure(entry.tickerId);
				entry.tickerInstance = t;
				COMP->tickables_map[entry.skill2Tick] = entry;				// add entry in the map
				COMP->yarpTickers_list.push_back(t);						// keep a list of ticker to easy destroy them at the closure
			}
			else if(entry.tickerType == "smartsoft")
			{
				SmartTicker *t = new SmartTicker(COMP->stateMaster);		// create new SmartSoft ticker
				success = t->configure(entry.tickerId);
				entry.tickerInstance = t;
				COMP->tickables_map[entry.skill2Tick] = entry;				// add entry in the map
				COMP->smartTickers_list.push_back(t);						// keep a list of ticker to easily destroy them at the closure
			}
			else if(entry.tickerType == "RelayTicker")
			{
				// This tickers are created "statically" before entering this loop, (I cannot created them
				// as many as I want) so if I get here there is something wrong.
				std::string errorStr = "Cannot instantiate a <RelayTicker> for skill <" + entry.skill2Tick + ">.";
				yError() << errorStr;
				yError() << "Known skills are ";
				for(auto b : tmpVect)
					std::cout << b.skillName << std::endl;
				throw std::invalid_argument(errorStr);
			}
			else
			{
				std::string errorStr = "ERROR: Requested ticker " + entry.tickerType + " not found!";
				throw std::invalid_argument(errorStr);
			}

			if(!success)
			{
				std::string errorStr = "ERROR: Failed instantiating ticker " + entry.tickerType;
				throw std::invalid_argument(errorStr);
			}

			std::cout << " done" << std::endl;
		}
//		std::cout << std::endl << std::endl;
    }

    // opening debug port
    COMP->debugPort.open("/tickDispatcher/debug:o");
    yarp::os::Network::connect(COMP->debugPort.getName(), "/btDebug:i");

    COMP->blackboardPort.open("/tickDispatcher/black:o");
    yarp::os::Network::connect(COMP->blackboardPort.getName(), "/blackboard/rpc:i");

	yInfo() << "DONE";

	// Start all services. If you need manual control, use the content of this function to
	// connect and start each service individually, e.g:
	// COMP->connectMyPortName("SmartExampleComponent", "examplePort");
	status = COMP->connectAndStartAllServices();
	
	// Start all tasks. If you need manual control, use the content of this function to
	// start each task individually.
	COMP->startAllTasks();
	
	// Start all timers. If you need manual control, use the content of this function to
	// start each timer individually.
	COMP->startAllTimers();
	
	// Notify the component that setup/initialization is finished.
	// You may move this function to any other place.
	COMP->setStartupFinished();
}

void CompHandler::onShutdown() 
{
	std::cout << "shutdown - put your cleanup code in CompHandler::onShutdown()!!!\n";
	
}
