//--------------------------------------------------------------------------
// Code generated by the SmartSoft MDSD Toolchain
// The SmartSoft Toolchain has been developed by:
//  
// Service Robotics Research Center
// University of Applied Sciences Ulm
// Prittwitzstr. 10
// 89075 Ulm (Germany)
//
// Information about the SmartSoft MDSD Toolchain is available at:
// www.servicerobotik-ulm.de
//
// This file is generated once. Modify this file to your needs. 
// If you want the toolchain to re-generate this file, please 
// delete it before running the code generator.
//--------------------------------------------------------------------------
#include "CompHandler.hh"
#include "BT_TickManager.hh"

#include "tickers/yarpTicker.h"
#include <yarp/os/LogStream.h>
#include "tickers/ITickable.h"
#include "BT_TickManagerCore.hh"


// include communication objects

using namespace std;

void CompHandler::onStartup() 
{
	std::cout << "startup - put your startupCode in CompHandler::onStartup()!!!\n";

	Smart::StatusCode status;

	COMP->stateMaster = new SmartACE::StateMaster(COMP->component);

	/* Load config file */
	std::string file(COMP->getGlobalState().getSettings().getConfigFile());

    std::ifstream myFile;

    vector<vector<string> > inputData;

    myFile.open(file.c_str() , std::ios::in);
    if(!myFile.is_open())
    {
    	std::cout << "\nerror opening file " << file << std::endl;
    	return;
    }
    else
    {
		/* Read it */
		string line;
		std::cout << "\n reading file " << file << std::endl;

		while(!myFile.eof())
		{
			getline(myFile, line);

//			std::cout << "Got a new line:  " << line << std::endl;

			istringstream ticker(line);
			vector<string> tokens {istream_iterator<string>{ticker}, istream_iterator<string>{}};

//			std::cout << "tokens size:  " << tokens.size() << std::endl;

			if(tokens.size() == 0)		// skip blank lines
				continue;

	    	if(tokens.size() < 4)
	    	{
	    		std::cout << "Error: line " << line << " malformed. Some parameters are missing";
	    		continue;
	    	}

/*
			for(int i=0;  i< tokens.size(); i++)
				std::cout << i << " " << tokens[i] << std::endl;
*/
			inputData.push_back(tokens);
		}
		myFile.close();
		std::cout << "Config file loaded\n";
    }

    /* Instantiate devices */
    for (auto tokens : inputData)
    {
    	Info entry;

		for(int i=0; i<tokens.size(); i++)
			std::cout << tokens[i] << "  |  ";

		entry.skill2Tick = tokens[0];
		entry.tickerType = tokens[1];
		entry.tickerId   = tokens[2];
		entry.command    = tokens[3];

		if(tokens.size() >= 5)
			entry.params     = tokens[4];

		bool found = false;
		for (auto &elem : COMP->tickables_map)
		{
			if( (elem.second.tickerType == entry.tickerType) && (elem.second.tickerId == entry.tickerId) )
			{
				// Ticker already exists.
				std::cout << "Using an already existing ticker ... ";
				found = true;
				entry.tickerInstance = elem.second.tickerInstance;		// re-cycle already existing ticker
				COMP->tickables_map[entry.skill2Tick] = entry;			// add entry in the map
				break;
			}
		}
		std::cout << std::endl;

		if(!found)		// create new instance
		{
			if(entry.tickerType == "yarp")
			{
				std::cout << "Creating a new YARP ticker ... ";
				YarpTicker *t = new YarpTicker();							// create new yarp ticker
				t->configure(entry.tickerId);
				entry.tickerInstance = t;
				COMP->tickables_map[entry.skill2Tick] = entry;				// add entry in the map
				COMP->yarpTickers_list.push_back(t);						// keep a list of ticker to easy destroy them at the closure
			}

			if(entry.tickerType == "smartsoft")
			{
				std::cout << "Create a new smartsoft ticker ... ";
				SmartTicker *t = new SmartTicker(COMP->stateMaster);		// create new SmartSoft ticker
				t->configure(entry.tickerId);
				entry.tickerInstance = t;
				COMP->tickables_map[entry.skill2Tick] = entry;				// add entry in the map
				COMP->smartTickers_list.push_back(t);						// keep a list of ticker to easily destroy them at the closure
			}
			std::cout << " done" << std::endl;
		}
//		std::cout << std::endl << std::endl;
    }

	yInfo() << "DONE";

	// Start all services. If you need manual control, use the content of this function to
	// connect and start each service individually, e.g:
	// COMP->connectMyPortName("SmartExampleComponent", "examplePort");
	status = COMP->connectAndStartAllServices();
	
	// Start all tasks. If you need manual control, use the content of this function to
	// start each task individually.
	COMP->startAllTasks();
	
	// Start all timers. If you need manual control, use the content of this function to
	// start each timer individually.
	COMP->startAllTimers();
	
	// Notify the component that setup/initialization is finished.
	// You may move this function to any other place.
	COMP->setStartupFinished();
}


bool CompHandler::is_whitespace(const std::string& s)
{
	for(auto it = s.begin(); it != s.end(); ++it)
	{
		if(!isspace(*it))
		{
			return false;
		}
	}
	return true;
}

void CompHandler::onShutdown() 
{
	std::cout << "shutdown - put your cleanup code in CompHandler::onShutdown()!!!\n";
	
}
