//--------------------------------------------------------------------------
// Code generated by the SmartSoft MDSD Toolchain
// The SmartSoft Toolchain has been developed by:
//  
// Service Robotics Research Center
// University of Applied Sciences Ulm
// Prittwitzstr. 10
// 89075 Ulm (Germany)
//
// Information about the SmartSoft MDSD Toolchain is available at:
// www.servicerobotik-ulm.de
//
// This file is generated once. Modify this file to your needs. 
// If you want the toolchain to re-generate this file, please 
// delete it before running the code generator.
//--------------------------------------------------------------------------
#include "TickHandler.hh"
#include "GraspingSkill.hh"

#include <yarp/os/LogStream.h>

using namespace std;

TickHandler::TickHandler(Smart::IQueryServerPattern<CommYARP_BT::CommTickCommand, CommYARP_BT::CommTickResult, SmartACE::QueryId>* server)
:	TickHandlerCore(server)
{
	
}

TickHandler::~TickHandler()
{
	
}

CommYARP_BT::TickResult TickHandler::handle_tick_goTo(const  std::vector<double> target)
{

}

CommYARP_BT::TickResult TickHandler::handle_tick_check(const std::vector<double> target)
{
	double enc[8];
	CommYARP_BT::TickResult result = CommYARP_BT::TickResult::Failure;

	COMP->armEnc->getEncoders(enc);

	// Check if all joints are in place
	bool done_arm = true;
	for(int i=0; i<8; i++)
	{
		done_arm &= (abs(enc[i] - target[i]) < 2);
//		yInfo() << "abs(encs[i]) " << abs(enc[i] - target[i]) << " " << done_arm;
	}

	if(done_arm)
	{
		yInfo() << "Position reached";
		result = CommYARP_BT::TickResult::Success;
	}
	return result;
}

void TickHandler::handleQuery(const SmartACE::QueryId &id, const CommYARP_BT::CommTickCommand& request) 
{
	// init helper variables
	CommYARP_BT::CommTickResult answer;
	CommYARP_BT::TickResult result = CommYARP_BT::TickResult::Failure;

	// debug print
	std::cout << "Received request " << request.getCommand() << "  --  " << request.getParameter() << std::endl;

	// handle input parameters
	CommYARP_BT::TickCommand::ENUM_TickCommand cmd = request.getCommand();

	// Parse param string into vector
	std::string params = request.getParameter();
	vector<string> paramsVect;
	stringstream ss(params);
	string temp;
	while (ss >> temp)
		paramsVect.push_back(temp);

	switch(cmd)
	{
		case CommYARP_BT::TickCommand::Tick:
		{
			if(paramsVect[0] == "goTo")
			{
				if(paramsVect[1] == "lift_right_arm")
				{
					// Send the command to a dummy target position
					if(handle_tick_check(dummyPos_rightArm) == CommYARP_BT::TickResult::Success)
					{
						result = CommYARP_BT::TickResult::Success;
					}
					else
					{
						yInfo() << "Moving arm";
						COMP->armPos->positionMove(dummyPos_rightArm.data());
						result = CommYARP_BT::TickResult::Running;
					}
				}
			}
			if(paramsVect[0] == "check")
			{
				if(paramsVect[1] == "lift_right_arm")
				{
					if(handle_tick_check(dummyPos_rightArm) == CommYARP_BT::TickResult::Success)
					{
						result = CommYARP_BT::TickResult::Success;
					}
				}
			}

		} break;

		case CommYARP_BT::TickCommand::Halt:
		{
			// Dummy halt
			result = CommYARP_BT::TickResult::Success;
		} break;
	}

	// implement your query handling logic here and fill in the answer object
	answer.setResult(result);
	this->server->answer(id, answer);
}
