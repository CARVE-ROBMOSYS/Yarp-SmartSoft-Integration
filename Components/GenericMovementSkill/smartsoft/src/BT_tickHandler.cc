//--------------------------------------------------------------------------
// Code generated by the SmartSoft MDSD Toolchain
// The SmartSoft Toolchain has been developed by:
//  
// Service Robotics Research Center
// University of Applied Sciences Ulm
// Prittwitzstr. 10
// 89075 Ulm (Germany)
//
// Information about the SmartSoft MDSD Toolchain is available at:
// www.servicerobotik-ulm.de
//
// This file is generated once. Modify this file to your needs. 
// If you want the toolchain to re-generate this file, please 
// delete it before running the code generator.
//--------------------------------------------------------------------------
#include "BT_tickHandler.hh"
#include "GenericMovementSkill.hh"

#include <numeric>
#include <yarp/os/Bottle.h>
#include <yarp/os/LogStream.h>

using namespace std;
using namespace yarp::os;

BT_tickHandler::BT_tickHandler(Smart::IQueryServerPattern<CommYARP_BT::CommTickCommand, CommYARP_BT::CommTickResult, SmartACE::QueryId>* server)
:	BT_tickHandlerCore(server)
{
	
}

BT_tickHandler::~BT_tickHandler()
{
	
}

bool BT_tickHandler::isJointTargetReached(string part)
{
	bool done;
	COMP->controlMap[part]->checkMotionDone(&done);
	return done;
}

bool BT_tickHandler::isCartesianTargetReached(string part)
{
	Bottle cmd, reply;
	cmd.addString("get");
	cmd.addString("done");

	if(part=="left_arm")
    {
    	COMP->cartesianLeftArm.write(cmd, reply);
    }
    else if(part=="right_arm")
    {
    	COMP->cartesianRightArm.write(cmd, reply);
    }

	if(reply.get(1).asInt8() == 1)
	{
		return true;
	}
	else
	{
		return false;
	}
}

bool BT_tickHandler::setNewJointTarget(Bottle *inner)
{
	string part = inner->get(1).asString();
	int nJoints = inner->size() - 2;
	std::vector<int> joints(nJoints);
	std::vector<double> vals(nJoints);
	std::iota(begin(joints), end(joints), 0);

	for(int tmp=0; tmp<nJoints; tmp++)		// Bottle has not begin, end and iterator, so cannot use std algorithms
	{
		vals[tmp] = inner->get(tmp+2).asDouble();
	}

	COMP->controlMap[part]->positionMove(nJoints, joints.data(), vals.data());
	return true;
}

bool BT_tickHandler::halt()
{
	for_each(partList.begin(), partList.end(), [this](string part)
	{
		if(isGoalJointSpace)
		{
			COMP->controlMap[part]->stop();
		}
		else
		{
			Bottle stopBottle;
			stopBottle.addString("stop");
			if(part=="left")
			{
				COMP->cartesianLeftArm.write(stopBottle);
			}
			else if(part=="right")
			{
				COMP->cartesianRightArm.write(stopBottle);
			}
		}
	});
	partList.clear();
	return true;
}

bool BT_tickHandler::setNewCartesianTarget(Bottle *inner)
{
	// Prepare bottle for cartesian command
	yarp::os::Bottle cartesian_cmd, reply;
	cartesian_cmd.addString("go");

	Bottle &payLoad1=cartesian_cmd.addList();
	Bottle &payLoad1a = payLoad1.addList();
	payLoad1a.addString("parameters");

	Bottle &payLoad2=payLoad1a.addList();

	Bottle &mode=payLoad2.addList();
	mode.addString("mode");
	mode.addString("full_pose+no_torso_no_heave");

	Bottle &torso_heave=payLoad2.addList();
	torso_heave.addString("torso_heave");
	torso_heave.addDouble(0.1);

	Bottle &lower_arm_heave=payLoad2.addList();
	lower_arm_heave.addString("lower_arm_heave");
	lower_arm_heave.addDouble(0.05);

	Bottle &target=payLoad1.addList();
	target.addString("target");
	Bottle &target2=target.addList();

	target2.addDouble(inner->get(2).asDouble());
	target2.addDouble(inner->get(3).asDouble());
	target2.addDouble(inner->get(4).asDouble());
	target2.addDouble(inner->get(5).asDouble());
	target2.addDouble(inner->get(6).asDouble());
	target2.addDouble(inner->get(7).asDouble());
	target2.addDouble(inner->get(8).asDouble());

	string part = inner->get(1).asString();
	if(part=="left_arm")
	{
		COMP->cartesianLeftArm.write(cartesian_cmd, reply);
	}
	else if(part=="right_arm")
	{
		COMP->cartesianRightArm.write(cartesian_cmd, reply);
	}
	else
	{
		yError() << "part " << part << " not supported, use left_arm or right_arm";
		return false;
	}
	if(reply.get(0).asVocab() == Vocab::encode("ack"))
	{
		return true;
	}
	else
	{
		return false;
	}
}


void BT_tickHandler::handleQuery(const SmartACE::QueryId &id, const CommYARP_BT::CommTickCommand& request) 
{
	// implement your query handling logic here and fill in the answer object
	CommYARP_BT::CommTickResult answer;

	if(request.getCommand() == CommYARP_BT::TickCommand::Halt)
	{
		halt();
		answer.setResult(CommYARP_BT::TickResult::Halted);

		this->server->answer(id, answer);
		return;
	}

	// get info from blackboard
	Bottle cmd, reply;
	cmd.addString("get");
	cmd.addString(request.getParameter());
	COMP->blackBoardRPC.write(cmd, reply);

	yDebug() << "Received reply from blackboard: " << reply.toString();

	string type = reply.get(0).asString();
	Bottle *listOfLists = reply.get(1).asList();
	string conditionName = reply.get(2).asString();

	// The command may contains more than one goal at the same time
	for(int i=0; i<listOfLists->size(); i++)
	{
		bool done = true;
		Bottle *target = listOfLists->get(i).asList();
		string part = target->get(0).asString();

		if(isRunning)
		{
			if(isGoalJointSpace)
			{
				done &= isJointTargetReached(part);
			}
			else
			{
				done &= isCartesianTargetReached(part);
			}

			if(!done)
				answer.setResult(CommYARP_BT::TickResult::Running);
			else
			{
				answer.setResult(CommYARP_BT::TickResult::Success);
				isRunning = false;
			}
		}
		else
		{
			// check if command is in joint space or cartesian space
			if(type == "joint")
			{
				isGoalJointSpace = true;
				setNewJointTarget(target);
				answer.setResult(CommYARP_BT::TickResult::Running);
			}
			else if(type == "cartesian")
			{
				isGoalJointSpace = false;
				setNewCartesianTarget(target);
				answer.setResult(CommYARP_BT::TickResult::Running);
			}
			else
			{
				yError() << "Command undefined " << target->toString();
				yError() << "Expecting joint( (left_arm j1 j2 j3) (right_arm j1 j2 j3)) \n or cartesian ( (left_arm x y z orient) (right_arm x y z orient)) ";
				answer.setResult(CommYARP_BT::TickResult::Error);
			}
		}
	}

	if(answer.getResult() == CommYARP_BT::TickResult::Success)
	{
		cmd.addString("set");
		cmd.addString(conditionName);
		cmd.addString("True");
		COMP->blackBoardRPC.write(cmd, reply);
	}
	this->server->answer(id, answer);
}
