//--------------------------------------------------------------------------
// Code generated by the SmartSoft MDSD Toolchain
// The SmartSoft Toolchain has been developed by:
//  
// Service Robotics Research Center
// University of Applied Sciences Ulm
// Prittwitzstr. 10
// 89075 Ulm (Germany)
//
// Information about the SmartSoft MDSD Toolchain is available at:
// www.servicerobotik-ulm.de
//
// This file is generated once. Modify this file to your needs. 
// If you want the toolchain to re-generate this file, please 
// delete it before running the code generator.
//--------------------------------------------------------------------------
#include "BT_tickHandler.hh"
#include "GenericMovementSkill.hh"

#include <numeric>
#include <yarp/os/Bottle.h>
#include <yarp/os/LogStream.h>
#include <BTMonitorMsg.h>

using namespace std;
using namespace yarp::os;

BT_tickHandler::BT_tickHandler(Smart::IQueryServerPattern<CommYARP_BT::CommTickCommand, CommYARP_BT::CommTickResult, SmartACE::QueryId>* server)
:	BT_tickHandlerCore(server)
{
	toMonitor_port.open("/genericMovement/monitor:o");
}

BT_tickHandler::~BT_tickHandler()
{
	toMonitor_port.close();
}

bool BT_tickHandler::isJointTargetReached(string part)
{
	bool done;
	COMP->controlMap[part]->checkMotionDone(&done);
	return done;
}

bool BT_tickHandler::isCartesianTargetReached(string part)
{
	Bottle cmd, reply;
	cmd.addString("get");
	cmd.addString("done");

	if(part=="left_arm")
    {
    	COMP->cartesianLeftArm.write(cmd, reply);
    }
    else if(part=="right_arm")
    {
    	COMP->cartesianRightArm.write(cmd, reply);
    }

	if(reply.get(1).asInt8() == 1)
	{
		return true;
	}
	else
	{
		return false;
	}
}

bool BT_tickHandler::setNewJointTarget(Bottle *inner)
{
	string part = inner->get(0).asString();
	int nJoints = inner->size() - 1;
	std::vector<int> joints(nJoints);
	std::vector<double> vals(nJoints);
	std::iota(begin(joints), end(joints), 0);


	for(int tmp=0; tmp<nJoints; tmp++)		// Bottle has not begin / end iterators, so cannot use std algorithms
	{
		vals[tmp] = inner->get(tmp+1).asDouble();
	}

	COMP->controlMap[part]->positionMove(nJoints, joints.data(), vals.data());
	return true;
}

bool BT_tickHandler::halt()
{
	for_each(partList.begin(), partList.end(), [this](string part)
	{
		if(isGoalJointSpace)
		{
			COMP->controlMap[part]->stop();
		}
		else
		{
			Bottle stopBottle;
			stopBottle.addString("stop");
			if(part=="left")
			{
				COMP->cartesianLeftArm.write(stopBottle);
			}
			else if(part=="right")
			{
				COMP->cartesianRightArm.write(stopBottle);
			}
		}
	});
	partList.clear();
	return true;
}

bool BT_tickHandler::setNewCartesianTarget(Bottle *inner)
{
	if(!COMP->useCartesian)
	{
		std::cout << "Module is not configured to use the cartesian! Set <useCartesian> flag to true.";
		return false;
	}
	// Prepare bottle for cartesian command
	yarp::os::Bottle cartesian_cmd, reply;
	cartesian_cmd.addString("go");

	Bottle &payLoad1=cartesian_cmd.addList();
	Bottle &payLoad1a = payLoad1.addList();
	payLoad1a.addString("parameters");

	Bottle &payLoad2=payLoad1a.addList();

	Bottle &mode=payLoad2.addList();
	mode.addString("mode");
	mode.addString("full_pose+no_torso_no_heave");

	Bottle &torso_heave=payLoad2.addList();
	torso_heave.addString("torso_heave");
	torso_heave.addDouble(0.1);

	Bottle &lower_arm_heave=payLoad2.addList();
	lower_arm_heave.addString("lower_arm_heave");
	lower_arm_heave.addDouble(0.05);

	Bottle &target=payLoad1.addList();
	target.addString("target");
	Bottle &target2=target.addList();

	target2.addDouble(inner->get(2).asDouble());
	target2.addDouble(inner->get(3).asDouble());
	target2.addDouble(inner->get(4).asDouble());
	target2.addDouble(inner->get(5).asDouble());
	target2.addDouble(inner->get(6).asDouble());
	target2.addDouble(inner->get(7).asDouble());
	target2.addDouble(inner->get(8).asDouble());

	string part = inner->get(1).asString();
	if(part=="left_arm")
	{
		COMP->cartesianLeftArm.write(cartesian_cmd, reply);
	}
	else if(part=="right_arm")
	{
		COMP->cartesianRightArm.write(cartesian_cmd, reply);
	}
	else
	{
		yError() << "part " << part << " not supported, use left_arm or right_arm";
		return false;
	}
	if(reply.get(0).asVocab() == Vocab::encode("ack"))
	{
		return true;
	}
	else
	{
		return false;
	}
}


void BT_tickHandler::handleQuery(const SmartACE::QueryId &id, const CommYARP_BT::CommTickCommand& request) 
{
	// implement your query handling logic here and fill in the answer object
	CommYARP_BT::CommTickResult answer;

	if(request.getCommand() == CommYARP_BT::TickCommand::Halt)
	{
		halt();
		answer.setResult(CommYARP_BT::TickResult::Halted);

		this->server->answer(id, answer);
		return;
	}

	// get info from blackboard
	yDebug() << "Getting parameters for " << request.getParameter();
	Bottle cmd, reply;
	cmd.addString("get");
	cmd.addString(request.getParameter());
	COMP->blackBoardRPC.write(cmd, reply);
	yDebug() << "Received reply from blackboard: " << reply.toString();

	Bottle *t, tmp;
	tmp.fromString(reply.get(0).asString());

	t = tmp.get(0).asList();
	yDebug() << "tmp from reply: " << tmp.toString();

	string type = t->get(0).asString();
	Bottle *listOfLists = t->get(1).asList();
	string conditionName = t->get(2).asString();

	yDebug() << "type: " << type;
	yDebug() << "conditionName: " << conditionName;


	auto found = COMP->statusMap.find(conditionName);
	if( found != COMP->statusMap.end() )
	{
		if( (found->second == CommYARP_BT::TickResult::Success) || (found->second == CommYARP_BT::TickResult::Failure) )
		{
			yInfo() << "action " << conditionName << " done with result " << found->second;
			if(found->second == CommYARP_BT::TickResult::Success)
			{
				yError() << "Setting " << conditionName << __LINE__;
				cmd.clear();
				cmd.addString("set");
				cmd.addString(conditionName);
				cmd.addString("True");
				bool wrote = COMP->blackBoardRPC.write(cmd, reply);
				yWarning() << " write on blackboard ret " << wrote;
/*
				// send signal to the monitors
				BTMonitorMsg msg;
				msg.skill     = conditionName;
				msg.event     = "e_req";
				bool ret = toMonitor_port.write(msg);
				yWarning() << " sent msg to monitor " << msg.skill << msg.event << ret;

				// send signal to the monitors
				// BTMonitorMsg msg;
				msg.skill     = conditionName;
				msg.event     = "e_from_env";
				wrote = toMonitor_port.write(msg);
				yWarning() << " write to monitor ret " << wrote;
*/
			}
			answer.setResult(found->second);
			this->server->answer(id, answer);
			return;
		}
	}


	// send signal to the monitors
	BTMonitorMsg msg;
	if(conditionName == "BottleGrasped")
		msg.skill = "GraspBottle";
	else
		msg.skill     = conditionName;

	msg.event     = "e_req";
	bool ret = toMonitor_port.write(msg);
	yWarning() << " sent msg to monitor " << msg.skill << msg.event << ret;

	// The command may contains more than one goal at the same time
	bool done = true;
	for(int i=0; i<listOfLists->size(); i++)
	{
		Bottle *target = listOfLists->get(i).asList();
		string part = target->get(0).asString();

		yWarning() << i << " target "  << target->size();
		yWarning() << i << " part "  << part;

		if(found != COMP->statusMap.end())
		{
			yError() << __LINE__;

			if(isGoalJointSpace)
			{
				done &= isJointTargetReached(part);
				yInfo() << "done part " << part << " is " << done;
			}
			else
			{
				done &= isCartesianTargetReached(part);
			}
		}
		else
		{
			yError() << __LINE__;
			done = false;

			// check if command is in joint space or cartesian space
			if(type == "joint")
			{
				isGoalJointSpace = true;
				setNewJointTarget(target);
				answer.setResult(CommYARP_BT::TickResult::Running);
				isRunning = true;
				yError() << __LINE__;
				COMP->statusMap[conditionName] = CommYARP_BT::TickResult::Running;
			}
			else if(type == "cartesian")
			{
				isGoalJointSpace = false;
				setNewCartesianTarget(target);
				answer.setResult(CommYARP_BT::TickResult::Running);
				COMP->statusMap[conditionName] = CommYARP_BT::TickResult::Running;
			}
			else
			{
				yError() << "Command undefined " << target->toString();
				yError() << "Expecting joint( (left_arm j1 j2 j3) (right_arm j1 j2 j3)) \n or cartesian ( (left_arm x y z orient) (right_arm x y z orient)) ";
				answer.setResult(CommYARP_BT::TickResult::Error);
			}
		}
	}

	COMP->statusMap[conditionName] = answer.getResult();

	if(isRunning && done)
	{
		answer.setResult(CommYARP_BT::TickResult::Success);
		COMP->statusMap[conditionName] = CommYARP_BT::TickResult::Success;
	}
	else
	{
		answer.setResult(CommYARP_BT::TickResult::Running);
		COMP->statusMap[conditionName] = CommYARP_BT::TickResult::Running;
	}

	if(answer.getResult() == CommYARP_BT::TickResult::Success)
	{
		yError() << "Setting " << conditionName << __LINE__;
		cmd.clear();
		cmd.addString("set");
		cmd.addString(conditionName);
		cmd.addString("True");
		bool wrote = COMP->blackBoardRPC.write(cmd, reply);
		yWarning() << " write on blackboard ret " << wrote << " reply " << reply.toString();

		// send signal to the monitors
		BTMonitorMsg msg;
		if(conditionName == "BottleGrasped")
			msg.skill = "GraspBottle";
		else
			msg.skill     = conditionName;
		msg.event     = "e_from_env";
		wrote = toMonitor_port.write(msg);
		yWarning() << " write to monitor ret " << wrote;
	}
	this->server->answer(id, answer);
	return;
}
