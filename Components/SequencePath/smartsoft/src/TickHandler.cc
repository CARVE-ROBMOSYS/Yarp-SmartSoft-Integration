//--------------------------------------------------------------------------
// Code generated by the SmartSoft MDSD Toolchain
// The SmartSoft Toolchain has been developed by:
//  
// Service Robotics Research Center
// University of Applied Sciences Ulm
// Prittwitzstr. 10
// 89075 Ulm (Germany)
//
// Information about the SmartSoft MDSD Toolchain is available at:
// www.servicerobotik-ulm.de
//
// This file is generated once. Modify this file to your needs. 
// If you want the toolchain to re-generate this file, please 
// delete it before running the code generator.
//--------------------------------------------------------------------------
#include "TickHandler.hh"
#include "SequencePath.hh"

using namespace std;
using namespace CommYARP_BT;


TickHandler::TickHandler(Smart::IQueryServerPattern<CommYARP_BT::CommTickCommand, CommYARP_BT::CommTickResult, SmartACE::QueryId>* server)
:	TickHandlerCore(server)
{
	
}

TickHandler::~TickHandler()
{
	
}


void TickHandler::handleQuery(const SmartACE::QueryId &id, const CommYARP_BT::CommTickCommand& request) 
{

	CommYARP_BT::TickCommand cmd = request.getCommand();
	CommYARP_BT::TickResult  res = CommYARP_BT::TickResult::Error;
	std::string tickParam = request.getParameter();

	std::cout << "\n\n-----\nTick Manager Received tick request [id " << id << "] " << tickParam << std::endl;

	//	sleep(4);

	COMP->reqId = id;
	COMP->cmd = request;
	COMP->isNewData = true;
	COMP->gotNewData.notify_all();

	std::cout << "callback returns " << std::endl;

/*
	//-------------------------------------------------
	CommTickResult navigationAnswer, myAnswer;
	CommTickCommand myRequest;

	myRequest.setCommand(TickCommand::Tick);
	myRequest.setParameter(COMP->inputData[COMP->currentStep]);

	myAnswer.setResult(TickResult::Running);


	std::cout << "Sequencer [id " << id << "]:  Got request " << request << std::endl;

	COMP->tickClient->query(myRequest, navigationAnswer);

	std::cout << "Sequencer [id " << id << "]:  Nav answer " << navigationAnswer << std::endl;

	switch(navigationAnswer.getResult() )
	{
		case TickResult::Success:
		{
			while(navigationAnswer.getResult() == TickResult::Success)
			{
				COMP->currentStep++;
				if(COMP->currentStep >= COMP->inputData.size())
				{
					// All steps are done, the path succeeded
					myAnswer.setResult(TickResult::Success);
					break;
				}
				myRequest.setParameter(COMP->inputData[COMP->currentStep]);
				COMP->tickClient->query(myRequest, navigationAnswer);
			}
		} break;

		case TickResult::Failure:
		{
			myAnswer.setResult(TickResult::Failure);
		} break;

		case TickResult::Running:
		{
			myAnswer.setResult(TickResult::Running);
		} break;
	}

	std::cout << "Sequencer [id " << id << "]:  My  answer " << myAnswer << std::endl;

	this->server->answer(id, myAnswer);
*/
}
