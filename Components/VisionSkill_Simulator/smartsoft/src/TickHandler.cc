//--------------------------------------------------------------------------
// Code generated by the SmartSoft MDSD Toolchain
// The SmartSoft Toolchain has been developed by:
//  
// Service Robotics Research Center
// University of Applied Sciences Ulm
// Prittwitzstr. 10
// 89075 Ulm (Germany)
//
// Information about the SmartSoft MDSD Toolchain is available at:
// www.servicerobotik-ulm.de
//
// This file is generated once. Modify this file to your needs. 
// If you want the toolchain to re-generate this file, please 
// delete it before running the code generator.
//--------------------------------------------------------------------------
#include "TickHandler.hh"
#include "VisionSkill_Simulator.hh"

#include <yarp/os/Bottle.h>
#include <yarp/os/Network.h>
#include <yarp/os/LogStream.h>
#include <BTMonitorMsg.h>

using namespace std;
using namespace yarp::os;

TickHandler::TickHandler(Smart::IQueryServerPattern<CommYARP_BT::CommTickCommand, CommYARP_BT::CommTickResult, SmartACE::QueryId>* server)
:	TickHandlerCore(server)
{
	bool ret = false;
	std::cout << "BT_tick_Handler::BT_tick_Handler" << std::endl;
	ret = blackBoard_Client.open("/VisionSkill/blackboard:o");
	ret &= yarp::os::Network::connect("/VisionSkill/blackboard:o", "/blackboard/rpc:i");
	if(!ret)
	{
		yError() << "Cannot connect to YARP blackboard";
	}

	ret = toGazeboWorld.open("/VisionSkill_gazebo/worldInterface/rpc");
	ret &= yarp::os::Network::connect(toGazeboWorld.getName(), "/world_input_port");
	if(!ret)
	{
		yError() << "Cannot connect to YARP blackboard";
	}
	toMonitor_port.open("/visionSkill/monitor:o");
}

TickHandler::~TickHandler()
{
	
}


void TickHandler::handleQuery(const SmartACE::QueryId &id, const CommYARP_BT::CommTickCommand& request) 
{
	// init helper variables
	CommYARP_BT::CommTickResult answer;
	CommYARP_BT::TickResult result = CommYARP_BT::TickResult::Failure;

	// handle tick
	CommYARP_BT::TickCommand::ENUM_TickCommand cmd = request.getCommand();
	string params = request.getParameter();

	// send signal to the monitors
	if(cmd == CommYARP_BT::TickCommand::Tick)
	{
		yDebug() << " Sending e_req to LocateBottle";
		BTMonitorMsg msg;
		msg.skill     = "LocateBottle";
		msg.event     = "e_req";
		toMonitor_port.write(msg);
	}

	// Do actual job
	std::cout << "Received request " << request.getCommand() << "  --  " << request.getParameter() << std::endl;
	yarp::os::Bottle worldInt_request, worldReply;
	worldInt_request.addString("getPose");
	worldInt_request.addString(request.getParameter());
	worldInt_request.addString("SIM_CER_ROBOT::mobile_base_body_link");
	toGazeboWorld.write(worldInt_request, worldReply);

	yDebug() << worldReply.toString();

	switch(cmd)
	{
		case CommYARP_BT::TickCommand::Tick:
		{
			Bottle toBoard, reply;
			toBoard.addString("set");
			toBoard.addString("BottleLocated");
			toBoard.addString("True");
			blackBoard_Client.write(toBoard, reply);

			toBoard.clear();
			reply.clear();
			toBoard.addString("set");
			toBoard.addString("BottlePose");
	        Bottle &subcmd = toBoard.addList();
	        for(int i=0 ; i<3 ; i++)
	        {
	            subcmd.addDouble(worldReply.get(i+1).asDouble());
	        }
			blackBoard_Client.write(toBoard, reply);

			yDebug() << "Setting BottlePose to value " << toBoard.toString() << " inside the blackboard";
			result = CommYARP_BT::TickResult::Success;

			// send signal to the monitors
			BTMonitorMsg msg;
			msg.skill     = "LocateBottle";
			msg.event     = "e_from_env";
			toMonitor_port.write(msg);
			yDebug() << "Sending <LocateBottle e_from_env> to monitor";

		} break;

		case CommYARP_BT::TickCommand::Halt:
		{
			// Dummy halt
			result = CommYARP_BT::TickResult::Halted;
		} break;
	}

	// implement your query handling logic here and fill in the answer object
	answer.setResult(result);
	this->server->answer(id, answer);
	return;
}
