//--------------------------------------------------------------------------
// Code generated by the SmartSoft MDSD Toolchain
// The SmartSoft Toolchain has been developed by:
//  
// Service Robotics Research Center
// University of Applied Sciences Ulm
// Prittwitzstr. 10
// 89075 Ulm (Germany)
//
// Information about the SmartSoft MDSD Toolchain is available at:
// www.servicerobotik-ulm.de
//
// This file is generated once. Modify this file to your needs. 
// If you want the toolchain to re-generate this file, please 
// delete it before running the code generator.
//--------------------------------------------------------------------------
#include <string>
#include <iostream>

#include "BT_tick_Handler.hh"
#include "YarpNavigationClient.hh"

#include <yarp/os/Vocab.h>
#include <yarp/os/LogStream.h>

using namespace std;
using namespace yarp::os;

BT_tick_Handler::BT_tick_Handler(Smart::IQueryServerPattern<CommYARP_BT::CommTickCommand, CommYARP_BT::CommTickResult, SmartACE::QueryId>* server)
:	BT_tick_HandlerCore(server)
{
	bool ret = false;
	std::cout << "BT_tick_Handler::BT_tick_Handler" << std::endl;
	ret = blackBoard_Client.open("/yarpNavigationClient/blackboard:o");
	ret &= yarp::os::Network::connect("/yarpNavigationClient/blackboard:o", "/blackboard/rpc:i");
	if(!ret)
	{
		yError() << "Cannot connect to YARP blackboard";
	}
}

BT_tick_Handler::~BT_tick_Handler()
{
	COMP->iNav->stopNavigation();
}


void BT_tick_Handler::handleQuery(const SmartACE::QueryId &id, const CommYARP_BT::CommTickCommand& request) 
{
	// init values
	CommYARP_BT::CommTickResult answer;
	CommYARP_BT::TickResult result = CommYARP_BT::TickResult::Failure;
	yarp::dev::NavigationStatusEnum status = yarp::dev::navigation_status_error;

	// debug prints
	std::cout << "\n*********************************************" << std::endl;
	std::cout << "Received request " << request.getCommand() << "  --  " << request.getParameter() << std::endl;
	std::cout << "has goal " << has_goal << std::endl;


	if(!COMP->initialized)
	{
		yInfo() << "Module is not fully initialized yet. Cannot process callback.";
		answer.setResult(result);

		// Debug print
		yDebug() << "ID " <<  id << " req " << request.getParameter() << "; result " << result.to_string();

		this->server->answer(id, answer);
		return;
	}

	// implement your query handling logic here and fill in the answer object

	CommYARP_BT::TickCommand::ENUM_TickCommand cmd = request.getCommand();

	// Parse param string into vector
	std::string params = request.getParameter();
	vector<string> paramsVect;
	stringstream ss(params);
	string temp;
	while (ss >> temp)
		paramsVect.push_back(temp);

	for(int i=0; i< paramsVect.size(); i++)
		yInfo() << "param [" << i << "] is " << paramsVect[i];

	// Get absolute position of 'location' from blackboard
	Bottle toBoard, reply;
	toBoard.addString("get");
	toBoard.addString(paramsVect[1]);
	blackBoard_Client.write(toBoard, reply);

	// yDebug() << "Got reply from blackboard " << reply.toString();

	// get actual data from string reply
	yarp::dev::Map2DLocation desiredLoc;
	stringstream ss2(reply.toString().c_str()+1);
	ss2 >> desiredLoc.map_id;
	ss2 >> desiredLoc.x;
	ss2 >> desiredLoc.y;
	ss2 >> desiredLoc.theta;

	yInfo() << "desired Loc is " << desiredLoc.toString();

	// handle command
	switch(cmd)
	{
		case CommYARP_BT::TickCommand::Tick:
		{
			// Get subcommand: goTo or check
			if(paramsVect[0] == "goTo")
				result = handle_tick_goTo(desiredLoc, paramsVect[1]);

			if(paramsVect[0] == "check")
				result = handle_tick_check(desiredLoc);
		} break;

		case CommYARP_BT::TickCommand::Halt:
		{
			COMP->iNav->stopNavigation();
			has_goal = false;
			result = CommYARP_BT::TickResult::Success;
		} break;
	}

	answer.setResult(result);

	// Debug print
	yDebug() << "ID " <<  id << " req " << request.getParameter() << "; result " << result.to_string();

	this->server->answer(id, answer);
}

void BT_tick_Handler::writeBlackBoard(bool reached, string locationName)
{
	yInfo() << "Location reached is " << reached;

	CommYARP_BT::TickResult result = CommYARP_BT::TickResult::Success;
	yarp::os::Bottle cmd, response;
	cmd.addString("set");
	cmd.addString("RobotAt"+locationName);
	cmd.addString(reached?"True":"False");
	blackBoard_Client.write(cmd, response);
	return;
}

CommYARP_BT::TickResult  BT_tick_Handler::handle_tick_goTo(yarp::dev::Map2DLocation location, string locationName)
{
	CommYARP_BT::TickResult inLoco = CommYARP_BT::TickResult::Failure;
	CommYARP_BT::TickResult result = CommYARP_BT::TickResult::Running;

	if(has_goal)
	{
		yarp::dev::NavigationStatusEnum status;
		COMP->iNav->getNavigationStatus(status);
		std::cout << " navigation status " << yarp::os::Vocab::decode(status) << std::endl;

		inLoco = handle_tick_check(location);

		yInfo() << " in loco " << inLoco;

		switch(status)
		{
			case yarp::dev::navigation_status_error:
			case yarp::dev::navigation_status_failing:
			case yarp::dev::navigation_status_aborted:
				result = CommYARP_BT::TickResult::Failure;
				has_goal = false;
				break;

			case yarp::dev::navigation_status_goal_reached:
			case yarp::dev::navigation_status_idle:
				if(inLoco == CommYARP_BT::TickResult::Success)
				{
					yarp::dev::Map2DLocation lastTarget;

					COMP->iNav->getAbsoluteLocationOfCurrentTarget(lastTarget);
					yInfo() << "SUCCESS: current target is " << lastTarget.toString();
					result = CommYARP_BT::TickResult::Success;
					has_goal = false;
				}
				else
					result = CommYARP_BT::TickResult::Running;
				break;
			default:
				result = CommYARP_BT::TickResult::Running;
		}
	}
	else
	{
		std::cout << "Calling gotoTargetByAbsoluteLocation..." << std::endl ;
		yInfo() << "NEW target is " << location.toString();

		// get navigation parameters from blackboard
		Bottle config, reply;
		config.clear();
		reply.clear();
		config.addString("get");
		config.addString(locationName + "_navParams");
		blackBoard_Client.write(config, reply);

		Bottle ccc;
		ccc.fromString(reply.get(0).asString());

		// yInfo() << "navigation parameters for target " << locationName << " are " << reply.toString() << "  " << reply.size();
		yInfo() << "navigation parameters for target " << locationName << " are " << ccc.toString();

		config.clear();
		config.addString("set_robot_radius");
		config.addFloat64(ccc.get(0).asFloat64());
		COMP->pathPlanner_port.write(config, reply);
		yInfo() << "response is " << reply.toString();

		sleep(1);

		config.clear();
		config.addString("get_robot_radius");
		COMP->pathPlanner_port.write(config, reply);
		yInfo() << "response is " << reply.toString();

		config.clear();
		config.addString("set");
		config.addString("obstacle_stop");
		config.addInt32( (ccc.get(1).asString() == "False" ? 0 : 1) );
		COMP->goTo_port.write(config, reply);
		yInfo() << "response is " << reply.toString();

		config.clear();
		config.addString("set");
		config.addString("obstacle_avoidance");
		config.addInt32( (ccc.get(1).asString() == "False" ? 0 : 1) );
		COMP->goTo_port.write(config, reply);
		yInfo() << "response is " << reply.toString();

		sleep(1);

		if( COMP->iNav->gotoTargetByAbsoluteLocation(location) )   // this may require some time (???)
		{
			result = CommYARP_BT::TickResult::Running;
			has_goal = true;
		}
		std:: cout << "Returning " << result << std::endl;
	}

	writeBlackBoard((result == CommYARP_BT::TickResult::Success)? true : false, locationName);
	return result;
}

CommYARP_BT::TickResult BT_tick_Handler::handle_tick_check(yarp::dev::Map2DLocation desiredLoc)
{
	CommYARP_BT::TickResult result = CommYARP_BT::TickResult::Failure;

	// get actual data from string reply
	yarp::dev::Map2DLocation robotLoc;

	// get current robot position
	bool ret = COMP->iNav->getCurrentPosition(robotLoc);

	yInfo() << "Get [" << ret << "] Current robot location is " << robotLoc.toString();
	yInfo() << "Diff is " << std::fabs(desiredLoc.x - robotLoc.x) << "  " << std::fabs(desiredLoc.y - robotLoc.y);


	std::cout << std::fabs(desiredLoc.x - robotLoc.x) << std::endl;
	std::cout << std::fabs(desiredLoc.y - robotLoc.y) << std::endl;
	std::cout << std::fabs(desiredLoc.theta - robotLoc.theta) << std::endl;

	// Position matches if robot is inside a 0.1 circle.
	if( (std::fabs(desiredLoc.x 		- robotLoc.x)     <= 0.25) &&
		(std::fabs(desiredLoc.y 		- robotLoc.y)     <= 0.25) &&
	    (std::fabs(desiredLoc.theta 	- robotLoc.theta) <= 5.0) )
	{
		yWarning() << "Locattion reached";
		result = CommYARP_BT::TickResult::Success;
	}
	else
	{
		yWarning() << "Running";
		result = CommYARP_BT::TickResult::Failure;
	}
	return result;
}

