//--------------------------------------------------------------------------
// Code generated by the SmartSoft MDSD Toolchain
// The SmartSoft Toolchain has been developed by:
//  
// Service Robotics Research Center
// University of Applied Sciences Ulm
// Prittwitzstr. 10
// 89075 Ulm (Germany)
//
// Information about the SmartSoft MDSD Toolchain is available at:
// www.servicerobotik-ulm.de
//
// This file is generated once. Modify this file to your needs. 
// If you want the toolchain to re-generate this file, please 
// delete it before running the code generator.
//--------------------------------------------------------------------------
#include "CompHandler.hh"
#include "BT_TickManager.hh"

#include <iostream>
#include "tickers/yarpTicker.h"
#include <yarp/os/LogStream.h>
#include "tickers/ITickable.h"
#include "BT_TickManagerCore.hh"


// include communication objects

using namespace std;

void CompHandler::onStartup() 
{
	std::cout << "startup - put your startupCode in CompHandler::onStartup()!!!\n";

	Smart::StatusCode status;

	COMP->stateMaster = new SmartACE::StateMaster(COMP->component);

	/* Load config file */
	std::string file(COMP->getGlobalState().getSettings().getConfigFile());

    std::ifstream myFile;

    vector<vector<string> > inputData;

    myFile.open(file.c_str() , std::ios::in);
    if(!myFile.is_open())
    	std::cout << "\nerror opening file\n";
    else
    {
		/* Read it */
		string line;
		while(!myFile.eof())
		{
			std::cout << std::endl << "Got a new line:  ";
			getline(myFile, line);

			istringstream ticker(line);
			vector<string> tokens {istream_iterator<string>{ticker}, istream_iterator<string>{}};
			inputData.push_back(tokens);
		}
		myFile.close();

		std::cout << "Config file loaded " << file << "\n";
    }

    /* Instantiate devices */
    for (auto tokens : inputData)
    {
    	Info entry;

		for(int i=0; i<tokens.size(); i++)
			std::cout << tokens[i] << "  |  ";

		entry.skill2Tick = tokens[0];
		entry.tickerType = tokens[1];
		entry.tickerId   = tokens[2];
		entry.command    = tokens[3];
		entry.params     = tokens[4];

		bool found = false;
		for (auto &elem : COMP->tickables_map)
		{
			if( (elem.second.tickerType == entry.tickerType) && (elem.second.tickerId == entry.tickerId) )
			{
				// Ticker already exists.
				found = true;
				entry.tickerInstance = elem.second.tickerInstance;		// re-cycle already existing ticker
				COMP->tickables_map[entry.skill2Tick] = entry;			// add entry in the map
			}
		}

		if(!found)		// create new instance
		{
			if(entry.tickerType == "yarp")
			{
				std::cout << "Create a new YARP ticker " << std::endl;
				YarpTicker *t = new YarpTicker();							// create new yarp ticker
				entry.tickerInstance = t;
				COMP->tickables_map[entry.skill2Tick] = entry;				// add entry in the map
				COMP->yarpTickers_list.push_back(t);						// keep a list of ticker to easy destroy them at the closure
			}

			if(entry.tickerType == "smartsoft")
			{
				std::cout << "Create a new smartsoft ticker " << std::endl;
				SmartTicker *t = new SmartTicker(COMP->stateMaster);		// create new SmartSoft ticker
				entry.tickerInstance = t;
				COMP->tickables_map[entry.skill2Tick] = entry;				// add entry in the map
				COMP->smartTickers_list.push_back(t);						// keep a list of ticker to easily destroy them at the closure
			}
		}
		std::cout << std::endl << std::endl;
    }

	yInfo() << "DONE";

	// Start all services. If you need manual control, use the content of this function to
	// connect and start each service individually, e.g:
	// COMP->connectMyPortName("SmartExampleComponent", "examplePort");
	status = COMP->connectAndStartAllServices();
	
	// Start all tasks. If you need manual control, use the content of this function to
	// start each task individually.
	COMP->startAllTasks();
	
	// Start all timers. If you need manual control, use the content of this function to
	// start each timer individually.
	COMP->startAllTimers();
	
	// Notify the component that setup/initialization is finished.
	// You may move this function to any other place.
	COMP->setStartupFinished();
}

void CompHandler::onShutdown() 
{
	std::cout << "shutdown - put your cleanup code in CompHandler::onShutdown()!!!\n";
	
}
